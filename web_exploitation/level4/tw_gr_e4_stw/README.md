# PicoCTF2017  
## Writeup for Toaster Wars: Going Rogue Episode 4  

    Many saw the fourth installment of Toaster Wars: Going Rogue as a return to grace after the relative mediocrity of the third. I'm just glad it was made at all. And hey, they added some nifty new online scoreboard features, too!

Before I write about anything specific to this problem, it's important to note that it is the fourth problem of a series. It would be silly to act like this was the first, so I'll just write down a list of things we've learned from the previous problems.  

* The backend for the game is using Node.js
* The game serves static files, but the source of the static files seems to be the root of the server. This means that we can view file such as /package.json, which shows links to the server code.
* The server is located at /server/serv.js
* The game code is located at /server/game.js
* The core parts of the game are all secure. You cannot trick the game into moving you into any location. You cannot trick the server into putting a flag in your inventory, or anything of that sort.  

Next we'll check what's different about this version from the others. Below are the hints:  

    Ooh, what a nifty scoreboard! If we get a bunch of people playing at once, we can have a race through the dungeon!
    
Looks like a scoreboard has been added. But the hint also alludes to getting a bunch of people to play. This made us think that the problem could have something to do with a random chance that would take many attempts to do.  

First thing we did was take a normal run through the game. The last floor seems to have a set of stairs encased into blocks. Like I said in the list above, most of the core mechanics of the game are secure, so I know I can't just trick the server into making me walk through the walls or anything.  

The first idea that was made, was that there was an item that teleported you into a random location on the map, and maybe it could have teleported us onto the flag.  

We looked into the code for where that item is used, and saw the snipped below:  

    case "move":
				switch(effect.location){
					case "random":
						var newloc = { r: Math.floor(Math.random() * state.map.height), c: Math.floor(Math.random() * state.map.width) };

						while(state.map.grid[newloc.r][newloc.c] <= 0
							  || (state.map.stairs.r == newloc.r && state.map.stairs.c == newloc.c)
							  || utils.getEntityAtLocation(state, newloc.r, newloc.c) != null){
							newloc = { r: Math.floor(Math.random() * state.map.height), c: Math.floor(Math.random() * state.map.width) };
						}

						outcome.moveType = "warp";
						outcome.location = newloc;
						entity.location = newloc;
						break;
				}
				break;
        
Unfortunately, it looks like, if the location is equal to the location of the stairs, then a new location is generated. Therefore, this is not the right solution.  

After that, we were stumped for a while. We knew that the core movement functions were safe. How on earth could we reach the stairs? After looking through varios game code for a while, we stumbled upon this piece of code in /server/generator.js:  

    // Place player

			var playerLocation = {r: Math.floor(Math.random()*opts.map.height), c: Math.floor(Math.random()*opts.map.width)};

			while(grid[playerLocation.r][playerLocation.c] <= 0){
				playerLocation = {r: Math.floor(Math.random()*opts.map.height), c: Math.floor(Math.random()*opts.map.width)};
			}

			// Place stairs

			var stairsLocation = {r: Math.floor(Math.random()*opts.map.height), c: Math.floor(Math.random()*opts.map.width)};

			while(grid[stairsLocation.r][stairsLocation.c] <= 0 || (stairsLocation.r == playerLocation.r && stairsLocation.c == playerLocation.c)){
				stairsLocation = {r: Math.floor(Math.random()*opts.map.height), c: Math.floor(Math.random()*opts.map.width)};
			}

			if (opts.unfair) {
				grid[stairsLocation.r - 1][stairsLocation.c - 1] = -1;
				grid[stairsLocation.r - 1][stairsLocation.c] = -1;
				grid[stairsLocation.r - 1][stairsLocation.c + 1] = -1;
				grid[stairsLocation.r][stairsLocation.c - 1] = -1;
				grid[stairsLocation.r][stairsLocation.c + 1] = -1;
				grid[stairsLocation.r + 1][stairsLocation.c - 1] = -1;
				grid[stairsLocation.r + 1][stairsLocation.c] = -1;
				grid[stairsLocation.r + 1][stairsLocation.c + 1] = -1;
			}
      
To put this code into east to understand English:  

* First, the spawn location of the player is decided.
* Then, the location of the stairs is decided.
* Then, the code makes sure that the player did not spawn on the stairs.
* Then, the walls around the stairs are made.

So what does this mean? There is *nothing* in the code that prevents the player from spawning ontop of one of the blocks around the stairs. This also fits the hint in the case that it's something that you would need a lot of players running through the dungeon to get it. This is obviously something very rare.  

We thought about writing bots to do it, but in the end, we just decided to countlessly run it. We calculated the chance to be about one in three hundred. By the time we could have written a bot to constantly run the dungeon perfectly, we could have just manually gotten the flag anyway.  

We used a certain trick to get this done a lot faster. If on the first level, we did not spawn within a few tiles of the stairs, we refreshed. This made it much easier to reach the last floor.  

Unfortunately, we didn't count, but it took about 280-320 times to get it.

Flag: im_still_upset_you_dont_get_to_keep_the_cute_scarves_in_the_postgame_a44703668b068b3fa9a7a83a8f466ace
